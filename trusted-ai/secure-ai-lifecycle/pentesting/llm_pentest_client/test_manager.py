"""
Test execution and scheduling for LLM Penetration Testing.

Handles both one-time test execution and scheduled recurring tests.
"""

import time
from typing import Dict, Any, Optional, TYPE_CHECKING
from datetime import datetime

if TYPE_CHECKING:
    from .client import LLMPentestClient


class TestManager:
    """
    Manages pentest execution and scheduling.

    Supports both one-time tests and scheduled recurring tests with cron expressions.
    """

    def __init__(self, client: "LLMPentestClient"):
        """
        Initialize the test manager.

        Args:
            client: Parent LLMPentestClient instance.
        """
        self.client = client

    def start_one_time(
        self,
        resource_instance_id: str,
        scan_template_id: str,
        description: Optional[str] = None,
        pentest_connection_details: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Start a one-time penetration test.

        Args:
            resource_instance_id: ID of the LLM endpoint to test.
            scan_template_id: ID of the template to use for testing.
            description: Optional description of the test.
            pentest_connection_details: Optional override connection details.
                Use this to override the connection details defined when
                registering the endpoint.

        Returns:
            Test execution details including:
            - llm_pentest_scan_execution_id: Use to check status and download reports
            - task_id: Background task ID

        Example:
            result = client.tests.start_one_time(
                resource_instance_id="endpoint-123",
                scan_template_id="template-456",
                description="Weekly security check"
            )
            execution_id = result['llm_pentest_scan_execution_id']

            # Check status
            status = client.tests.get_status(execution_id)
        """
        data = {
            "resource_instance_id": resource_instance_id,
            "customer_id": self.client.customer_id
        }

        if description:
            data["description"] = description

        if pentest_connection_details:
            data["pentest_connection_details"] = pentest_connection_details

        endpoint = f"/v1/llm-pentest/scan_templates/{scan_template_id}/start"
        return self.client.make_request(endpoint, method="POST", data=data)

    def get_status(self, execution_id: str) -> Dict[str, Any]:
        """
        Get the status of a test execution.

        Args:
            execution_id: ID of the execution to check.

        Returns:
            Execution status details including:
            - status: RUNNING, COMPLETED, FAILED, or ERROR
            - progress information
            - results (if completed)

        Example:
            status = client.tests.get_status("execution-123")
            print(f"Status: {status['status']}")
            if status['status'] == 'COMPLETED':
                print("Test complete!")
        """
        endpoint = (
            f"/v1/llm-pentest/customers/{self.client.customer_id}"
            f"/executions/{execution_id}"
        )
        return self.client.make_request(endpoint)

    def wait_for_completion(
        self,
        execution_id: str,
        poll_interval: int = 30,
        timeout: int = 3600
    ) -> Dict[str, Any]:
        """
        Wait for a test execution to complete.

        Polls the API at regular intervals until the test completes or times out.

        Args:
            execution_id: ID of the execution to wait for.
            poll_interval: Seconds between status checks (default: 30).
            timeout: Maximum seconds to wait (default: 3600 = 1 hour).

        Returns:
            Final execution status.

        Raises:
            TimeoutError: If execution doesn't complete within timeout.

        Example:
            result = client.tests.start_one_time(...)
            execution_id = result['llm_pentest_scan_execution_id']

            # Wait for completion
            final_status = client.tests.wait_for_completion(
                execution_id,
                poll_interval=60,
                timeout=7200  # 2 hours
            )

            if final_status['status'] == 'COMPLETED':
                # Generate report
                client.reports.generate_and_download([execution_id])
        """
        start_time = time.time()

        while True:
            if time.time() - start_time > timeout:
                raise TimeoutError(
                    f"Execution {execution_id} did not complete within {timeout} seconds"
                )

            status = self.get_status(execution_id)

            if status.get("status") in ["COMPLETED", "FAILED", "ERROR"]:
                return status

            time.sleep(poll_interval)

    def create_job(
        self,
        resource_instance_id: str,
        scan_template_id: str,
        description: Optional[str] = None,
        enabled: bool = True
    ) -> Dict[str, Any]:
        """
        Create a scheduled pentest job.

        Jobs define what to test and which template to use. You must add
        a schedule to the job to actually run tests.

        Args:
            resource_instance_id: ID of the LLM endpoint to test.
            scan_template_id: ID of the template to use for testing.
            description: Optional description of the job.
            enabled: Whether the job is enabled (default: True).

        Returns:
            Created job details including job_id.

        Example:
            job = client.tests.create_job(
                resource_instance_id="endpoint-123",
                scan_template_id="template-456",
                description="Daily security scans"
            )

            # Add a schedule
            client.tests.add_schedule(
                job_id=job['job_id'],
                cron_expression="0 2 * * ? *"  # Daily at 2 AM UTC
            )
        """
        data = {
            "job_type": "LLM_PENTEST_SCAN",
            "enabled": enabled,
            "data": {
                "resource_instance_id": resource_instance_id,
                "scan_template_id": scan_template_id
            }
        }

        if description:
            data["data"]["description"] = description

        endpoint = f"/v1/scheduling-jobs/{self.client.customer_id}/jobs"
        return self.client.make_request(endpoint, method="POST", data=data)

    def add_schedule(
        self,
        job_id: str,
        cron_expression: str,
        start_at: Optional[str] = None,
        end_at: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Add a schedule to a job.

        Schedules use Amazon EventBridge cron format.

        Args:
            job_id: ID of the job to schedule.
            cron_expression: Cron expression for the schedule.
                Format: "minute hour day-of-month month day-of-week year"
                Examples:
                - "0 12 * * ? *" - Daily at 12:00 PM UTC
                - "0 2 ? * MON *" - Every Monday at 2:00 AM UTC
                - "0 */6 * * ? *" - Every 6 hours
            start_at: ISO format start datetime (default: now).
            end_at: ISO format end datetime (optional).

        Returns:
            Created schedule details.

        Example:
            schedule = client.tests.add_schedule(
                job_id="job-123",
                cron_expression="0 2 * * ? *",  # Daily at 2 AM UTC
                end_at=(datetime.now() + timedelta(days=30)).isoformat()
            )
        """
        data = {
            "customer_id": self.client.customer_id,
            "cron_expression": cron_expression,
            "start_at": start_at or datetime.now().isoformat()
        }

        if end_at:
            data["end_at"] = end_at

        endpoint = (
            f"/v1/scheduling-jobs/{self.client.customer_id}"
            f"/jobs/{job_id}/schedules"
        )
        return self.client.make_request(endpoint, method="POST", data=data)

    def create_scheduled(
        self,
        resource_instance_id: str,
        scan_template_id: str,
        cron_expression: str,
        description: Optional[str] = None,
        start_at: Optional[str] = None,
        end_at: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Create a scheduled test with job and schedule in one call.

        Convenience method that creates both a job and its schedule.

        Args:
            resource_instance_id: ID of the LLM endpoint to test.
            scan_template_id: ID of the template to use.
            cron_expression: Cron expression for the schedule.
            description: Optional description of the test.
            start_at: ISO format start datetime (default: now).
            end_at: ISO format end datetime (optional).

        Returns:
            Dictionary with 'job' and 'schedule' details.

        Example:
            result = client.tests.create_scheduled(
                resource_instance_id="endpoint-123",
                scan_template_id="template-456",
                cron_expression="0 2 * * ? *",  # Daily at 2 AM UTC
                description="Daily production security scan",
                end_at=(datetime.now() + timedelta(days=90)).isoformat()
            )

            print(f"Job ID: {result['job']['job_id']}")
            print(f"Schedule ID: {result['schedule']['id']}")
        """
        job = self.create_job(
            resource_instance_id=resource_instance_id,
            scan_template_id=scan_template_id,
            description=description
        )

        schedule = self.add_schedule(
            job_id=job["job_id"],
            cron_expression=cron_expression,
            start_at=start_at,
            end_at=end_at
        )

        return {
            "job": job,
            "schedule": schedule
        }

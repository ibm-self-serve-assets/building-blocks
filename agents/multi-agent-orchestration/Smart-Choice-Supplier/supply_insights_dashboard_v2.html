<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Smart Choice Supplier Agent - Real-time supplier data from AI agent">
  <title>Smart Choice Supplier Agent</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    body { font-family: 'Arial', sans-serif; }
    .hero { background: linear-gradient(to right, #1E40AF, #3B82F6); }
  </style>
</head>
<body class="bg-gray-100">
  <nav class="bg-white shadow sticky top-0 z-10">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <div class="flex justify-between h-16">
        <div class="flex items-center"><h1 class="text-xl font-bold text-gray-800">Smart Choice Supplier Agent</h1></div>
        <div class="flex items-center space-x-4"><span class="text-gray-600">Embeddable Watsonx Orchestrate</span></div>
      </div>
    </div>
  </nav>

  <section class="hero text-white py-12 text-center">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <h2 class="text-3xl font-bold mb-4">Smart Choice Supplier Agent</h2>
      <p class="text-lg mb-6">Real-time supplier data powered by AI agent. Ask questions and see live updates.</p>
    </div>
  </section>

  <section class="py-8 bg-white">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <div class="bg-gray-50 p-6 rounded-lg shadow">
        <form id="prompt-form" class="mb-4 flex flex-col md:flex-row md:items-center md:space-x-4 space-y-3 md:space-y-0">
          <div class="flex-1 relative">
            <label for="prompt-input" class="block text-sm font-medium text-gray-700 mb-1">
              Ask the Smart Choice Supplier Agent
            </label>
            <div class="relative">
              <input
                id="prompt-input"
                name="prompt-input"
                class="w-full rounded-md border border-gray-300 px-4 py-2 pr-10 focus:border-indigo-500 focus:ring-indigo-500"
                placeholder="e.g., coffee suppliers in India"
                autocomplete="off"
              />
              <button
                type="button"
                id="prompt-dropdown-toggle"
                class="absolute inset-y-0 right-0 flex items-center px-3 text-gray-500 hover:text-gray-700 focus:outline-none"
                aria-label="Show prompt options"
              >
                â–¼
              </button>
              <ul
                id="prompt-suggestions-list"
                class="hidden absolute z-20 mt-1 w-full max-h-60 overflow-auto rounded-md border border-gray-200 bg-white shadow-lg"
              ></ul>
            </div>
          </div>
          <button
            type="button"
            id="prompt-submit-button"
            class="inline-flex items-center justify-center rounded-md bg-indigo-600 px-6 py-2 text-white font-semibold hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          >
            Submit
          </button>
        </form>
        <div class="mb-6 text-sm text-gray-600 space-y-1">
          <p>
            Ask natural questions. The agent returns a dynamic JSON list (data) and this page renders columns from the keys.
          </p>
          <p class="text-xs text-gray-500">
            Common fields: supplier_name, country, delivery_days, reliability_score, items, trade_volume, item_code, description, risk.
          </p>
        </div>
        <div id="root" class="min-h-[400px]"></div>
      </div>
    </div>
  </section>

  <section class="py-8 bg-gray-100">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
      <h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">Results</h2>
      <div class="bg-white p-6 rounded-lg shadow">
        <div id="supplier-table">
          <div id="table-container" class="overflow-x-auto">
            <table id="supplier-data-table" class="min-w-full table-auto">
              <thead id="table-head" class="bg-gray-50"></thead>
              <tbody id="table-body" class="bg-white divide-y divide-gray-200">
                <tr>
                  <td class="px-6 py-12 text-center text-gray-500">
                    <div class="text-center">
                      <div class="text-4xl mb-4">ðŸ“Š</div>
                      <p class="text-lg">No data yet</p>
                      <p class="text-sm">Ask the agent a question to populate results</p>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </section>

  <footer class="bg-gray-800 text-white py-6">
    <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 text-center">
      <p>&copy; 2025 Smart Choice Supplier Agent. Powered by IBM WatsonX Orchestrate.</p>
    </div>
  </footer>

  <script>
    // Simple approach: continuously check and replace JSON with message
    let messageReplaceInterval = null;

    // Prompt suggestions (combo box)
    const PROMPT_SUGGESTIONS = [
      "Give me all Coffee suppliers from India",
      "filter suppliers below 20 delivery days",
      "give me all suppliers with reliability above 90",
      "show item codes with descriptions",
      "list countries with high risk",
      "supplier trade stats"
    ];

    const promptInput = document.getElementById('prompt-input');
    const promptSubmitButton = document.getElementById('prompt-submit-button');
    const promptSuggestionsList = document.getElementById('prompt-suggestions-list');
    const promptToggle = document.getElementById('prompt-dropdown-toggle');

    function renderPromptSuggestions(filterText = '') {
      if (!promptSuggestionsList) return;

      const normalizedFilter = filterText.trim().toLowerCase();
      const filtered = PROMPT_SUGGESTIONS.filter(item =>
        item.toLowerCase().includes(normalizedFilter)
      );

      promptSuggestionsList.innerHTML = '';

      if (!filtered.length) {
        const emptyItem = document.createElement('li');
        emptyItem.className = 'px-4 py-2 text-sm text-gray-500';
        emptyItem.textContent = 'No suggestions';
        promptSuggestionsList.appendChild(emptyItem);
        return;
      }

      filtered.forEach(item => {
        const li = document.createElement('li');
        li.className = 'px-4 py-2 text-sm text-gray-700 hover:bg-indigo-50 hover:text-indigo-600 cursor-pointer';
        li.textContent = item;
        li.addEventListener('mousedown', function (event) {
          event.preventDefault();
          if (promptInput) {
            promptInput.value = item;
          }
          hidePromptSuggestions();
        });
        promptSuggestionsList.appendChild(li);
      });
    }

    function showPromptSuggestions(filterText = '') {
      if (!promptSuggestionsList) return;
      renderPromptSuggestions(filterText);
      promptSuggestionsList.classList.remove('hidden');
    }

    function hidePromptSuggestions() {
      if (!promptSuggestionsList) return;
      promptSuggestionsList.classList.add('hidden');
    }

    if (promptInput && promptSuggestionsList && promptToggle) {
      promptInput.addEventListener('focus', function () {
        showPromptSuggestions(promptInput.value);
      });

      promptInput.addEventListener('input', function (event) {
        showPromptSuggestions(event.target.value);
      });

      promptInput.addEventListener('blur', function () {
        setTimeout(hidePromptSuggestions, 150);
      });

      promptToggle.addEventListener('click', function () {
        if (promptSuggestionsList.classList.contains('hidden')) {
          showPromptSuggestions(promptInput.value);
          promptInput.focus();
        } else {
          hidePromptSuggestions();
        }
      });

      document.addEventListener('click', function (event) {
        if (!promptSuggestionsList.contains(event.target) && event.target !== promptInput && event.target !== promptToggle) {
          hidePromptSuggestions();
        }
      });
    }

    if (promptSubmitButton && promptInput) {
      promptSubmitButton.addEventListener('click', function () {
        const promptText = promptInput.value.trim();
        if (!promptText) {
          promptInput.focus();
          return;
        }

        if (window.wxChatInstance && typeof window.wxChatInstance.send === 'function') {
          try {
            window.wxChatInstance.send(promptText);
          } catch (error) {
            console.error('Failed to send message to chat:', error);
          }
        } else {
          console.warn('Chat instance not ready or send function unavailable. Message not sent:', promptText);
        }
      });

      promptInput.addEventListener('keydown', function (event) {
        if (event.key === 'Enter') {
          event.preventDefault();
          promptSubmitButton.click();
        }
      });
    }

    window.wxOConfiguration = {
      orchestrationID: "<Insert Orchestration ID here>",
      hostURL: "https://dl.watson-orchestrate.ibm.com",
      rootElementID: "root",
      showLauncher: true,
      chatOptions: {
        agentId: "<insert agent id here>",
        onLoad: function(instance) {
          console.log('WatsonX chat loaded, setting up event handlers...');
          window.wxChatInstance = instance;
          if (instance) {
            try {
              console.log('Chat instance available. Methods:', Object.keys(instance));
              if (instance.chat && instance.chat.sendMessage) {
                console.log('Chat sendMessage found under instance.chat.sendMessage');
              }
            } catch (debugError) {
              console.warn('Unable to inspect chat instance:', debugError);
            }
          } else {
            console.warn('Chat instance is undefined in onLoad callback');
          }
          
          // Start continuous replacement checker
          startMessageReplacer();
          
          instance.on('receive', function(event) {
            console.log('Response received from bot:', event);
            try {
              const extracted = extractJSONFromResponse(event);
              console.log('Extracted JSON:', extracted);
              
              // Update table with data array
              updateDynamicTable({ data: extracted.data || [] });
            } catch (error) {
              console.error('Error processing response:', error);
              showError('Error processing response: ' + error.message);
            }
          });
          console.log('Event handlers registered - table will update with responses');
        }
      }
    };

    function startMessageReplacer() {
      // Clear any existing interval
      if (messageReplaceInterval) {
        clearInterval(messageReplaceInterval);
      }
      
      // Simple: check every 500ms for JSON and replace with message
      messageReplaceInterval = setInterval(function() {
        const rootElement = document.getElementById('root');
        if (!rootElement) return;
        
        // Find all text nodes and elements that contain JSON
        rootElement.querySelectorAll('*').forEach(function(element) {
          const text = element.textContent || '';
          // Check if this looks like JSON with message and data
          if (text.includes('"message"') && text.includes('"data"') && text.trim().startsWith('{')) {
            try {
              const parsed = JSON.parse(text.trim());
              let messageText = null;
              
              // Check for top-level message
              if (parsed.message && typeof parsed.message === 'string') {
                messageText = parsed.message;
              }
              // Check for nested message in properties.message (string)
              else if (parsed.properties && parsed.properties.message && typeof parsed.properties.message === 'string') {
                messageText = parsed.properties.message;
              }
              // Check for message in properties structure (could be nested)
              else if (parsed.properties && parsed.properties.message) {
                const msg = parsed.properties.message;
                if (typeof msg === 'string') {
                  messageText = msg;
                } else if (msg.items && Array.isArray(msg.items) && msg.items.length > 0 && typeof msg.items[0] === 'string') {
                  messageText = msg.items[0];
                }
              }
              
              // Replace if we found a message and text is still JSON (not already replaced)
              if (messageText && (text.includes('"type"') || text.includes('"properties"') || text.includes('"wrap_data"') || text.length > messageText.length * 3)) {
                element.textContent = messageText;
                if (element.innerHTML) {
                  element.innerHTML = messageText.replace(/\n/g, '<br>');
                }
              }
            } catch (e) {
              // Try to extract JSON from partial text
              const jsonMatch = text.match(/\{[\s\S]*"message"[\s\S]*\}/);
              if (jsonMatch) {
                try {
                  const parsed = JSON.parse(jsonMatch[0]);
                  let messageText = null;
                  
                  // Check various message locations
                  if (parsed.message && typeof parsed.message === 'string') {
                    messageText = parsed.message;
                  } else if (parsed.properties && parsed.properties.message) {
                    const msg = parsed.properties.message;
                    if (typeof msg === 'string') {
                      messageText = msg;
                    } else if (msg.items && Array.isArray(msg.items) && msg.items.length > 0) {
                      messageText = typeof msg.items[0] === 'string' ? msg.items[0] : '';
                    }
                  }
                  
                  if (messageText) {
                    element.textContent = text.replace(jsonMatch[0], messageText);
                    if (element.innerHTML) {
                      element.innerHTML = element.innerHTML.replace(jsonMatch[0], messageText.replace(/\n/g, '<br>'));
                    }
                  }
                } catch (e2) {}
              }
            }
          }
        });
      }, 500); // Check every 500ms
    }

    function extractJSONFromResponse(event) {
      let responseContent = '';
      if (event.message && event.message.content) {
        if (Array.isArray(event.message.content)) {
          responseContent = event.message.content
            .filter(item => item.type === 'text')
            .map(item => item.text || item.content)
            .join(' ');
        } else if (typeof event.message.content === 'string') {
          responseContent = event.message.content;
        }
      }
      console.log('Raw response content:', responseContent);
      try {
        const jsonMatch = responseContent.match(/\{[\s\S]*\}/);
        const parsed = JSON.parse(jsonMatch ? jsonMatch[0] : responseContent);
        
        // New format: {data: [...], message: "..."}
        if (parsed && typeof parsed.message === 'string') {
          return {
            data: Array.isArray(parsed.data) ? parsed.data : [],
            message: parsed.message
          };
        }
        
        if (parsed && parsed.type === 'object') {
          // Extract message from various possible locations
          let message = '';
          if (parsed.message && typeof parsed.message === 'string') {
            message = parsed.message;
          } else if (parsed.properties && parsed.properties.message) {
            if (typeof parsed.properties.message === 'string') {
              message = parsed.properties.message;
            } else if (parsed.properties.message.items && Array.isArray(parsed.properties.message.items) && parsed.properties.message.items.length > 0) {
              message = typeof parsed.properties.message.items[0] === 'string' ? parsed.properties.message.items[0] : '';
            }
          }
          
          // Case A: top-level data array (with possible message in properties)
          if (Array.isArray(parsed.data)) {
            return { data: parsed.data, message: message };
          }
          // Case B: schema with properties.data.items being the actual array of rows
          if (parsed.properties && parsed.properties.data && Array.isArray(parsed.properties.data.items)) {
            return { data: parsed.properties.data.items, message: message };
          }
          // Case C: schema with unified arrays (suppliers/product_suppliers)
          if (parsed.properties) {
            const props = parsed.properties;
            const suppliers = Array.isArray(props?.suppliers?.items) ? props.suppliers.items : [];
            const productSuppliers = Array.isArray(props?.product_suppliers?.items) ? props.product_suppliers.items : [];
            const merged = mergeSuppliersArrays(suppliers, productSuppliers);
            if (merged.length) {
              return { data: merged, message: message };
            }
            const itemCodes = Array.isArray(props?.item_codes?.items) ? props.item_codes.items : [];
            if (itemCodes.length) {
              return { data: itemCodes, message: message };
            }
            const countryRisk = Array.isArray(props?.country_risk?.items) ? props.country_risk.items : [];
            if (countryRisk.length) {
              return { data: countryRisk, message: message };
            }
            return { data: [], message: message };
          }
        }
        return { data: Array.isArray(parsed) ? parsed : [], message: '' };
      } catch (parseError) {
        console.error('JSON parsing error:', parseError);
        throw new Error('Invalid JSON response: ' + responseContent);
      }
    }

    function mergeSuppliersArrays(suppliers, productSuppliers) {
      const merged = new Map();
      (productSuppliers || []).forEach(ps => {
        merged.set(ps.supplier_name, { supplier_name: ps.supplier_name, country: ps.country, delivery_days: ps.delivery_days });
      });
      (suppliers || []).forEach(sp => {
        const prev = merged.get(sp.supplier_name) || { supplier_name: sp.supplier_name };
        merged.set(sp.supplier_name, {
          supplier_name: sp.supplier_name,
          country: prev.country,
          delivery_days: prev.delivery_days,
          reliability_score: sp.reliability_score,
          items: sp.items,
          trade_volume: sp.trade_volume
        });
      });
      return Array.from(merged.values());
    }

    function updateDynamicTable(jsonData) {
      const tableHead = document.getElementById('table-head');
      const tableBody = document.getElementById('table-body');
      const rows = Array.isArray(jsonData?.data) ? jsonData.data : [];

      if (!rows.length) {
        tableHead.innerHTML = '';
        tableBody.innerHTML = `
          <tr>
            <td class="px-6 py-12 text-center text-gray-500">No data returned</td>
          </tr>`;
        return;
      }

      const headerSet = new Set();
      rows.forEach(r => Object.keys(r || {}).forEach(k => headerSet.add(k)));
      const headers = Array.from(headerSet);

      tableHead.innerHTML = '<tr>' + headers.map(h => `
        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">${h.replace(/_/g,' ')}</th>
      `).join('') + '</tr>';

      tableBody.innerHTML = '';
      rows.forEach(r => {
        const tr = document.createElement('tr');
        tr.className = 'hover:bg-gray-50';
        tr.innerHTML = headers.map(h => `
          <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-700">${safeCell(r[h])}</td>
        `).join('');
        tableBody.appendChild(tr);
      });

    }

    function safeCell(val) {
      if (val === null || val === undefined) return 'N/A';
      if (Array.isArray(val)) return val.join(', ');
      if (typeof val === 'object') return JSON.stringify(val);
      return String(val);
    }


    function showError(message) {
      const tableBody = document.getElementById('table-body');
      document.getElementById('table-head').innerHTML = '';
      tableBody.innerHTML = `
        <tr>
          <td class="px-6 py-12 text-center text-red-500">${message}</td>
        </tr>`;
    }

    setTimeout(function () {
      const script = document.createElement('script');
      script.src = `${window.wxOConfiguration.hostURL}/wxochat/wxoLoader.js?embed=true`;
      script.addEventListener('load', function () { wxoLoader.init(); });
      document.head.appendChild(script);
    }, 0);
  </script>
</body>
</html>
